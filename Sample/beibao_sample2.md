# 参考来源
[ PHP贪婪算法解决0-1背包问题实例分析 ](http://www.jb51.net/article/62663.htm)

# 分析
- 本问题使用的是"贪心算法"求解。
- 来源文章的标题不正确，本问题针对的`不是`“0-1背包问题”，而是“部分背包问题”，即每一种物品可以有非整数个，`0<=k<2`。。
    - 理由是是下面的代码
    ```php
    if($i<$len) $allprice+=$x[$i]->price*($totalweight/$x[$i]->weight);
    ```
- 贪心算法要求寻找最优解之前，**必须**针对所有物品重新排序
    - 排序的依据是“价值/重量比”，及单位价值，此数值越高的物品排列的越靠前。
    - 这样排序的理由是：向包里装物品的时候，优先选择重量较轻但价值较高的物品，最接近最优解。
    - 函数`tsort`针对物品进行了冒泡排序
- 贪心算法实际的处理过程（函数`tanxin`）只是在循环中把排序后的物品逐个放入背包，检查是否超过了背包最大重量。
- 根据其他算法文章[1]介绍，贪心算法无法得出“0-1背包问题”的最优整数解，只有允许出现部分物品（非整数个，如1.5个）的前提下，才能使用贪心算法得出最优解。

> 动态规划与贪心的区别：
> 
> 贪心算法： 
> 1. 贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留； 
> 2. 由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。 
> 
> 动态规划算法： 
> 1. 全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解 ；
> 2. 动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解 ；
> 3. 边界条件：即最简单的，可以直接得出的局部最优解。


# 运行结果
```
1 10
1 3
3 5
4 3
11 7
16 10
12 5
18 5
18 5
5 1
0-1背包最优解为:43.555555555556
```

[1]: http://www.voidcn.com/blog/sgs1018/article/p-2646820.html "其他算法文章" 